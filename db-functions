#!/hint/bash

. /usr/share/makepkg/util.sh

# global shell options for enhanced bash scripting
shopt -s extglob globstar nullglob


# Some PKGBUILDs need CARCH to be set
CARCH="x86_64"

# Useful functions
UMASK=""
set_umask () {
	export UMASK="${UMASK:-$(umask)}"
	umask 002
}

restore_umask () {
	umask "$UMASK" >/dev/null
}

# Proxy function to check if a file exists. Using [[ -f ... ]] directly is not
# always wanted because we might want to expand bash globs first. This way we
# can pass unquoted globs to is_globfile() and have them expanded as function
# arguments before being checked.
is_globfile() {
	[[ -f $1 ]]
}

# just like mv -f, but we touch the file and then copy the content so
# default ACLs in the target dir will be applied
mv_acl() {
	rm -f "$2"
	touch "$2"
	cat "$1" >"$2" || return 1
	rm -f "$1"
}

# set up general environment
WORKDIR=$(mktemp -dt "${0##*/}.XXXXXXXXXX")
LOCKS=()
REPO_MODIFIED=0

# set static gnupg directory for trusted keyring used by GnuPG, Git etc.
export GNUPGHOME="${KEYRING}"

script_lock() {
	local LOCKDIR="$TMPDIR/.scriptlock.${0##*/}"
	if ! mkdir "$LOCKDIR" >/dev/null 2>&1 ; then
		local _owner="$(/usr/bin/stat -c %U "$LOCKDIR")"
		error "Script %s is already locked by %s." "${0##*/}" "$_owner"
		exit 1
	else
		set_umask
		return 0
	fi
}

script_unlock() {
	local LOCKDIR="$TMPDIR/.scriptlock.${0##*/}"
	if [[ ! -d $LOCKDIR ]]; then
		warning "Script %s was not locked!" "${0##*/}"
		restore_umask
		return 1
	else
		rmdir "$LOCKDIR"
		restore_umask
		return 0
	fi
}

cleanup() {
	local status=${1:-$?}
	local l
	local repo
	local arch

	trap - EXIT INT QUIT TERM
	for l in "${LOCKS[@]}"; do
		repo=${l%.*}
		arch=${l#*.}
		if [[ -d $TMPDIR/.repolock.$repo.$arch ]]; then
			msg "Removing left over lock from [%s] (%s)" "$repo" "$arch"
			repo_unlock "$repo" "$arch"
		fi
	done
	if [[ -d $TMPDIR/.scriptlock.${0##*/} ]]; then
		msg "Removing left over lock from %s" "${0##*/}"
		script_unlock
	fi
	rm -rf "$WORKDIR"

	if (( REPO_MODIFIED )); then
		date +%s > "${FTP_BASE}/lastupdate"
	fi

	exit "$status"
}

abort() {
	msg 'Aborting...'
	cleanup 0
}

die() {
	error "$@"
	cleanup 1
}

trap abort INT QUIT TERM HUP
trap cleanup EXIT


stat_busy() {
	local mesg=$1; shift
	# shellcheck disable=2059
	printf "${GREEN}==>${ALL_OFF}${BOLD} ${mesg}...${ALL_OFF}" "$@" >&2
}

stat_done() {
	# shellcheck disable=2059
	printf "${BOLD}done${ALL_OFF}\n" >&2
}

##
#  usage : lock( $fd, $file, $message, [ $message_arguments... ] )
##
lock() {
	# Only reopen the FD if it wasn't handed to us
	if ! [[ "/dev/fd/$1" -ef "$2" ]]; then
		mkdir -p -- "$(dirname -- "$2")"
		eval "exec $1>"'"$2"'
	fi

	if ! flock -n "$1"; then
		stat_busy "${@:3}"
		flock "$1"
		stat_done
	fi
}

##
#  usage : slock( $fd, $file, $message, [ $message_arguments... ] )
##
slock() {
	# Only reopen the FD if it wasn't handed to us
	if ! [[ "/dev/fd/$1" -ef "$2" ]]; then
		mkdir -p -- "$(dirname -- "$2")"
		eval "exec $1>"'"$2"'
	fi

	if ! flock -sn "$1"; then
		stat_busy "${@:3}"
		flock -s "$1"
		stat_done
	fi
}

##
#  usage : lock_close( $fd )
##
lock_close() {
	local fd=$1
	# https://github.com/koalaman/shellcheck/issues/862
	# shellcheck disable=2034
	exec {fd}>&-
}

#repo_lock <repo-name> <arch> [timeout]
repo_lock() {
	local repo base=${1}; shift
	for repo in ${base} ${base}-debug; do
		_repo_lock ${repo} "${@}" || exit 1
	done
}

_repo_lock () {
	local LOCKDIR="$TMPDIR/.repolock.$1.$2"
	local DBLOCKFILE="${FTP_BASE}/${1}/os/${2}/${1}${DBEXT}.lck"
	local _count
	local _trial
	local _timeout
	local _lockblock
	local _owner

	# This is the lock file used by repo-add and repo-remove
	if [[ -f ${DBLOCKFILE} ]]; then
		error "Repo [%s] (%s) is already locked by repo-{add,remove} process %s" "$1" "$2" "$(cat "$DBLOCKFILE")"
		return 1
	fi

	if (( $# == 2 )); then
		_lockblock=true
		_trial=0
	elif (( $# == 3 )); then
		_lockblock=false
		_timeout=$3
		let _trial=$_timeout/$LOCK_DELAY
	fi

	_count=0
	while (( _count <= _trial )) || [[ $_lockblock = true ]]; do
		if ! mkdir "$LOCKDIR" >/dev/null 2>&1 ; then
			_owner="$(/usr/bin/stat -c %U "$LOCKDIR")"
			warning "Repo [%s] (%s) is already locked by %s." "$1" "$2" "$_owner"
			msg2 "Retrying in %s seconds..." "$LOCK_DELAY"
		else
			LOCKS+=("$1.$2")
			set_umask
			return 0
		fi
		sleep "$LOCK_DELAY"
		let _count=$_count+1
	done

	error "Repo [%s] (%s) is already locked by %s. Giving up!" "$1" "$2" "$_owner"
	return 1
}

#repo_unlock <repo-name> <arch>
repo_unlock () {
	local repo base=${1}; shift
	for repo in ${base} ${base}-debug; do
		_repo_unlock ${repo} "${@}"
	done
}

_repo_unlock () {
	local LOCKDIR="$TMPDIR/.repolock.$1.$2"
	if [[ ! -d $LOCKDIR ]]; then
		warning "Repo lock [%s] (%s) was not locked!" "$1" "$2"
		restore_umask
		return 1
	else
		rmdir "$LOCKDIR"
		restore_umask
		return 0
	fi
}

# usage: _grep_all_info pkgfile infofile key
_grep_all_info() {
	local _ret=()

	mapfile -t _ret < <(/usr/bin/bsdtar -xOqf "$1" "${2}" | grep "^${3} = ")

	printf '%s\n' "${_ret[@]#${3} = }"
}

# usage: _grep_pkginfo pkgfile pattern
_grep_pkginfo() {
	_grep_all_info "${1}" .PKGINFO "${2}" | tail -1
}

# usage: _grep_buildinfo pkgfile pattern
_grep_buildinfo() {
	_grep_all_info "${1}" .BUILDINFO "${2}" | tail -1
}

# Get the package base or name as fallback
getpkgbase() {
	local _base

	_base="$(_grep_pkginfo "$1" "pkgbase")"
	if [[ -z $_base ]]; then
		getpkgname "$1"
	else
		echo "$_base"
	fi
}

# Get the package name
getpkgname() {
	local _name

	_name="$(_grep_pkginfo "$1" "pkgname")"
	if [[ -z $_name ]]; then
		error "Package '%s' has no pkgname in the PKGINFO. Fail!" "$1"
		exit 1
	fi

	echo "$_name"
}

# Get the pkgver-pkgrel of this package
getpkgver() {
	local _ver

	_ver="$(_grep_pkginfo "$1" "pkgver")"
	if [[ -z $_ver ]]; then
		error "Package '%s' has no pkgver in the PKGINFO. Fail!" "$1"
		exit 1
	fi

	echo "$_ver"
}

getpkgarch() {
	local _ver

	_ver="$(_grep_pkginfo "$1" "arch")"
	if [[ -z $_ver ]]; then
		error "Package '%s' has no arch in the PKGINFO. Fail!" "$1"
		exit 1
	fi

	echo "$_ver"
}

getpkgdesc() {
	local _desc

	_desc="$(_grep_pkginfo "$1" "pkgdesc")"
	if [[ -z $_desc ]]; then
		error "Package '%s' has no pkgdesc in the PKGINFO. Fail!" "$1"
		exit 1
	fi

	echo "$_desc"
}

# TODO: We need to not depend on pkgdesc
#       here be dragons
is_debug_package() {
	local pkgfile=${1}
	local pkgbase pkgname pkgdesc

	if ! pkgbase="$(getpkgbase "${pkgfile}")" || \
			! pkgname="$(getpkgname "${pkgfile}")" || \
			! pkgdesc="$(getpkgdesc "${pkgfile}")"; then
		error "Failed to get PKGINFO metadata from package '%s'" "${pkgfile}"
		exit 1
	fi

	[[ ${pkgdesc} == "Detached debugging symbols for "* && ${pkgbase}-debug = "${pkgname}" ]]
}

check_packager() {
	local _packager
	local author author_email

	_packager=$(_grep_pkginfo "$1" "packager")
	if [[ $_packager == 'Unknown Packager' ]] || \
	   [[ -n ${PACKAGER_DOMAIN} ]] && [[ $_packager != *\<*@${PACKAGER_DOMAIN}\> ]]; then
		return 1
	fi
	if ! author=$(get_author) || \
	   ! author_email=$(get_author_email "${author}"); then
		return 1
	fi
	if [[ $_packager != *" <${author_email}>" ]]; then
		return 1
	fi
	return 0
}

check_buildinfo() {
	/usr/bin/bsdtar -tqf "$1" .BUILDINFO >/dev/null 2>&1
}

check_builddir() {
	local _builddir

	_builddir=$(_grep_buildinfo "$1" "builddir")
	[[ -n $_builddir && $_builddir = '/build' ]]
}

check_buildtool() {
	local _buildtool

	_buildtool=$(_grep_buildinfo "$1" "buildtool")
	[[ -n $_buildtool && $_buildtool = 'devtools' ]]
}

check_author() {
	local author
	if ! [[ -f "${AUTHORS}" ]]; then
		die "No such authors file: '%s'" "${AUTHORS}"
		return 1
	fi
	if ! author=$(get_author); then
		return 1
	fi
	return 0
}

get_author() {
	if ! username=$(/usr/bin/id -un); then
		die "Failed to get username from 'id'"
	fi
	if ! author=$(grep -E " ${username}\$" "${AUTHORS}"); then
		die "Missing author information for %s in '%s'" "${username}" "${AUTHORS}"
	fi
	echo "${author}"
}

get_author_name() {
	local author=$1
	if ! name=$(echo "${author}"|sed -E 's/(.+) (<.+>) .+/\1/'); then
		die "Failed to get name from author line"
	fi
	echo "${name}"
}

get_author_email() {
	local author=$1
	if ! email=$(echo "${author}"|sed -E 's/(.+) <(.+)> .+/\2/'); then
		die "Failed to get name from author line"
	fi
	echo "${email}"
}

# Non fatal getpkgfile expanding globs
maybe_getpkgfile() {
	if  (( $# != 1 )); then
		exit 1
	elif [[ ! -f ${1} ]]; then
		exit 1
	elif [[ ! -f ${1}.sig ]]; then
		error "Package signature %s not found!" "$1.sig"
		exit 1
	fi

	echo "${1}"
}

getpkgfile() {
	if  (( $# != 1 )); then
		error 'No canonical package found!'
		return 1
	elif [[ ! -f ${1} ]]; then
		error "Package %s not found!" "$1"
		return 1
	elif [[ ! -f ${1}.sig ]]; then
		error "Package signature %s not found!" "$1.sig"
		return 1
	fi

	echo "${1}"
}

meassure() {
	date +"%s%3N"
}

duration() {
	label=$1
	t1=$2
	t2=${3:-}
	if [[ -z $t2 ]]; then
		t2=$(meassure)
	fi
	duration=$(( t2 - t1 ))
	echo "${label}: ${duration} ms"
}

getpkgfiles() {
	local f files
	if ! printf '%s\n' "${@%\.*}" | awk 'a[$0]++{exit 1}'; then
		error 'Duplicate packages found!'
		exit 1
	fi

	for f in "$@"; do
		files+=("$(getpkgfile "$f")") || exit 1
	done

	if (( ${#files[@]} )); then
		printf "%s\n" "${files[@]}"
	fi

	return 0
}

check_pkgfile() {
	local pkgfile=$1

	local pkgname="$(getpkgname "${pkgfile}")" || return 1
	local pkgver="$(getpkgver "${pkgfile}")" || return 1
	local pkgarch="$(getpkgarch "${pkgfile}")" || return 1

	in_array "${pkgarch}" "${ARCHES[@]}" 'any' || return 1

	[[ ${pkgfile##*/} = "${pkgname}-${pkgver}-${pkgarch}"* ]]
}

# Check that the package file is consistent with the PKGBUILD in version control
check_pkgvcs() {
	local pkgfile="${1}"
	local repo="${2}"
	local _pkgbase="$(getpkgbase "${pkgfile}")" || return 1
	local _pkgname="$(getpkgname "${pkgfile}")" || return 1
	local _pkgver="$(getpkgver "${pkgfile}")" || return 1
	local _pkgarch="$(getpkgarch "${pkgfile}")" || return 1

	in_array "${repo}" "${PKGREPOS[@]}" || return 1

	local vcsver vcsnames=()
	read -rd'\n' vcsver vcsnames < <(source_pkgbuild "${_pkgbase}" "${_pkgver}"; \
	                                 get_full_version; echo "${pkgname[@]}")
	read -ra vcsnames <<<"${vcsnames}"

	[[ "${vcsver}" = "${_pkgver}" ]] || return 1
	in_array "${_pkgname}" "${vcsnames[@]}" "${_pkgbase}-debug" || return 1

	return 0
}

check_splitpkgs() {
	local repo="${1}"
	shift
	local pkgfiles=("${@}")
	local pkgfile
	local pkgdir
	local vcsname

	mkdir -p "${WORKDIR}/check_splitpkgs/"
	pushd "${WORKDIR}/check_splitpkgs" >/dev/null

	for pkgfile in "${pkgfiles[@]}"; do
		local _pkgbase="$(getpkgbase "${pkgfile}")"
		local _pkgname="$(getpkgname "${pkgfile}")"
		local _pkgarch="$(getpkgarch "${pkgfile}")"
		local _pkgver="$(getpkgver "${pkgfile}")"
		local vcsnames=($(source_pkgbuild "${_pkgbase}" "${_pkgver}"; echo "${pkgname[@]}"))

		# not a split package
		(( ${#vcsnames[@]} > 1 )) || continue
		[[ ${_pkgbase}-debug = ${_pkgname} ]] && continue

		mkdir -p "${repo}/${_pkgarch}/${_pkgbase}"
		echo "${_pkgname}" >> "${repo}/${_pkgarch}/${_pkgbase}/staging"

		printf '%s\n' "${vcsnames[@]}" >> "${repo}/${_pkgarch}/${_pkgbase}/vcs"
	done
	popd >/dev/null

	for pkgdir in "${WORKDIR}/check_splitpkgs/${repo}"/*/*; do
		[[ ! -d ${pkgdir} ]] && continue
		sort -u "${pkgdir}/staging" -o "${pkgdir}/staging"
		sort -u "${pkgdir}/vcs" -o "${pkgdir}/vcs"
		if [[ ! -z "$(comm -13 "${pkgdir}/staging" "${pkgdir}/vcs")" ]]; then
			return 1
		fi
	done

	return 0
}

check_pkgrepos() {
	local pkgfile=$1

	local pkgname="$(getpkgname "${pkgfile}")" || return 1
	local pkgver="$(getpkgver "${pkgfile}")" || return 1
	local pkgarch="$(getpkgarch "${pkgfile}")" || return 1

	is_globfile "${FTP_BASE}/${PKGPOOL}/${pkgname}-${pkgver}-${pkgarch}"${PKGEXTS} && return 1
	is_globfile "${FTP_BASE}/${PKGPOOL}/${pkgname}-${pkgver}-${pkgarch}"${PKGEXTS}.sig && return 1
	[[ -f ${FTP_BASE}/${PKGPOOL}/${pkgfile##*/} ]] && return 1
	[[ -f ${FTP_BASE}/${PKGPOOL}/${pkgfile##*/}.sig ]] && return 1

	return 0
}

check_stagingrepos() {
	local -n staging_ref=$1
	local pkgfile=${2}
	local pkgrepo=${3}

	local repo package_repos required_repo required_repos=()
	local staged_packages staged_pkgfile staged_pkgname
	local pkgbase pkgname pkgarch

	pkgbase=$(getpkgbase "${pkgfile}")
	pkgname=$(getpkgname "${pkgfile}")
	pkgarch=$(getpkgarch "${pkgfile}")

	# check if testing is required for stable
	if in_array "${pkgrepo}" "${STABLE_REPOS[@]}"; then
		mapfile -t package_repos < <(find_repo_for_package "${pkgbase}" "${pkgarch}" "${TESTING_REPOS[@]}")
		required_repos+=("${package_repos[@]}")
	fi
	# check if staging is required for stable,testing
	if in_array "${pkgrepo}" "${STABLE_REPOS[@]}" "${TESTING_REPOS[@]}"; then
		mapfile -t package_repos < <(find_repo_for_package "${pkgbase}" "${pkgarch}" "${STAGING_REPOS[@]}")
		required_repos+=("${package_repos[@]}")
	fi

	# check for each required repo
	for required_repo in "${required_repos[@]}"; do
		repo=${required_repo%-*}
		read -ra staged_packages <<< "${staging_ref[${repo}]}"

		# check if package is staged in required repo
		for staged_pkgfile in "${staged_packages[@]}"; do
			staged_pkgname=${staged_pkgfile##*/}
			staged_pkgname=${staged_pkgname%-*-*-*}
			# staged package found for repo
			if [[ ${pkgname} = "${staged_pkgname}" ]]; then
				continue 2
			fi
		done

		# missing staged package in repo
		printf '%s' "${repo}"
		return 1
	done

	# no staged packages required
	return 0
}

#usage: check_license ${license[@]}"
check_license() {
	local l
	for l in "${@}"; do
		in_array "${l}" "${ALLOWED_LICENSES[@]}" && return 0
	done

	return 1
}

check_repo_configured() {
	local repo=$1

	local count=$(printf '%s\n' "${PKGREPOS[@]}" | grep --count --line-regexp "$repo")
	[[ $count -gt 0 ]] && return 0

	return 1
}

check_repo_permission() {
	local repo=$1

	(( ${#PKGREPOS[@]} == 0 )) && return 1
	[[ -z "${PKGPOOL}" ]] && return 1

	in_array "${repo}" "${PKGREPOS[@]}" "${DEBUGREPOS[@]}" || return 1

	[[ -w $FTP_BASE/${PKGPOOL} ]] || return 1

	local arch
	for arch in "${ARCHES[@]}"; do
		local dir="${FTP_BASE}/${repo}/os/${arch}/"
		[[ -w ${dir} ]] || return 1
		[[ -f ${dir}${repo}${DBEXT} && ! -w ${dir}${repo}${DBEXT} ]] && return 1
		[[ -f ${dir}${repo}${FILESEXT} && ! -w ${dir}${repo}${FILESEXT} ]] && return 1
	done

	# Check unix group against ACL
	for group in $(/usr/bin/groups); do
		[ "${ACL[${group}]+exists}" ] || continue
		read -r -a acl_repos <<< "${ACL[${group}]}"
		in_array "${repo}" "${acl_repos[@]}" || continue
		return 0
	done

	return 1
}

set_repo_permission() {
	local repo=$1
	local arch=$2
	local dbfile="${FTP_BASE}/${repo}/os/${arch}/${repo}${DBEXT}"
	local filesfile="${FTP_BASE}/${repo}/os/${arch}/${repo}${FILESEXT}"

	if [[ -w ${dbfile} ]]; then
		local group=$(/usr/bin/stat --printf='%G' "$(dirname "${dbfile}")")
		chgrp "$group" "${dbfile}"    || error "Could not change group of %s to %s" "$dbfile" "$group"
		chgrp "$group" "${filesfile}" || error "Could not change group of %s to %s" "$filesfile" "$group"
		chmod g+w "${dbfile}"    || error "Could not set write permission for group %s to %s" "$group" "$dbfile"
		chmod g+w "${filesfile}" || error "Could not set write permission for group %s to %s" "$group" "$filesfile"
	else
		error "You don't have permission to change %s" "$dbfile"
	fi
}

arch_repo_modify() {
	local action=$1
	local repo=$2
	local arch=$3
	local pkgs=("${@:4}")
	local dbfile="${FTP_BASE}/${repo}/os/${arch}/${repo}${DBEXT}"
	local repo_action_opts=(--quiet)

	if [[ ${action} = remove && ! -f ${dbfile} ]]; then
		error "No database found at '%s'" "$dbfile"
		return 1
	fi

	if [[ ${action} = add ]]; then
		repo_action_opts+=(--prevent-downgrade)
	fi

	# package files for repo-add might be relative to repo dir
	pushd "${dbfile%/*}" >/dev/null
	if ! /usr/bin/"repo-${action}" "${repo_action_opts[@]}" "${dbfile}" "${pkgs[@]}"; then
		error '%s' "repo-${action} ${repo_action_opts[*]@Q} ${dbfile@Q} ${pkgs[*]@Q}"
		popd >/dev/null
		return 1
	fi
	set_repo_permission "${repo}" "${arch}"
	popd >/dev/null

	REPO_MODIFIED=1
}

# Verify the existence of dependent packages needed by all staged pkgfiles
# usage: check_reproducible staged_packages
check_reproducible() {
	local -n staging_ref=$1
	local repo pkgfile pkgname pkgfiles=()
	local dependency dependencies staged_packages

	declare -A dependencies
	declare -A staged_packages

	# collect all dependencies once in a lookup table
	for repo in "${!staging_ref[@]}"; do
		read -ra pkgfiles <<< "${staging_ref[$repo]}"
		for pkgfile in "${pkgfiles[@]}"; do
			mapfile -t pkg_dependencies < <(_grep_all_info "${pkgfile}" .BUILDINFO installed)
			for dependency in "${pkg_dependencies[@]}"; do
				array_append dependencies "${dependency}" "${pkgfile}"
			done
			dependency=${pkgfile##*/}
			# shellcheck disable=2295
			dependency=${dependency%*${PKGEXTS}}
			staged_packages["${dependency}"]="${pkgfile}"
		done
	done

	for dependency in "${!dependencies[@]}"; do
		pkgname=${dependency%-*-*-*}
		[ "${staged_packages["${dependency}"]+exists}" ] && continue

		# fast lookup with none glob file exists check using default PKGEXT
		[[ -f "${FTP_BASE}"/pool/packages/${dependency}${PKGEXT_DEFAULT} ]] && continue
		[[ -f "${ARCHIVE_BASE}/packages/${pkgname:0:1}/${pkgname}/${dependency}${PKGEXT_DEFAULT}" ]] && continue

		# fallback lookup in csae fast lookup with default pkgext fails
		# shellcheck disable=2086
		getpkgfile "${FTP_BASE}/pool/packages/${dependency}"${PKGEXTS} &>/dev/null && continue
		# shellcheck disable=2086
		getpkgfile "${ARCHIVE_BASE}/packages/${pkgname:0:1}/${pkgname}/${dependency}"${PKGEXTS} &>/dev/null && continue

		error "could not find existing or staged package for dependency %s" "${dependency}"
		error "Package %s is not reproducible." "${dependencies[${dependency}]##*/}"
		return 1
	done

	return 0
}

# TODO: Needs to verify the keyid is in the keyring
check_signed_tag(){
	local pkgbase="$(getpkgbase ${1})"
	local pkgver="$(gittag_from_pkgver "$(getpkgver "${1}")")"
	if ! git_tag_exists "${pkgbase}" "${pkgver}"; then
		return 1
	fi
	if ! git -C "${GIT_PACKAGES_CACHE}/${pkgbase}" verify-tag "${pkgver}" >/dev/null 2>&1; then
		return 1
	fi
	return 0
}

# Verified the package .BUIDINFO PKGBUID sha256sum against the checked out version
check_pkgbuild_checksum(){
	local pkgbase="$(getpkgbase ${1})"
	local pkgver="$(getpkgver ${1})"
	local pkgfile_checksum="$(_grep_buildinfo "${1}" "pkgbuild_sha256sum")"

	local gittag="$(gittag_from_pkgver "$(getpkgver "${1}")")"

	local sum="$(sha256sum <(git -C "${GIT_PACKAGES_CACHE}/${pkgbase}" show "${gittag}":PKGBUILD))"
	if [[ "$pkgfile_checksum" != "${sum%% *}" ]]; then
		return 1
	fi
}

get_stability_layer_from_repo() {
	local repo=$1
	if in_array "${repo}" "${STABLE_REPOS[@]}"; then
		echo stable
		return 0
	elif in_array "${repo}" "${TESTING_REPOS[@]}"; then
		echo testing
		return 0
	elif in_array "${repo}" "${STAGING_REPOS[@]}"; then
		echo staging
		return 0
	elif in_array "${repo}" "${UNSTABLE_REPOS[@]}"; then
		echo unstable
		return 0
	fi
	return 1
}

get_repos_from_stability_layer() {
	local layer=$1
	case $layer in
		stable)
			printf "%s\n" "${STABLE_REPOS[@]}"
			return 0
			;;
		testing)
			printf "%s\n" "${TESTING_REPOS[@]}"
			return 0
			;;
		staging)
			printf "%s\n" "${STAGING_REPOS[@]}"
			return 0
			;;
		unstable)
			printf "%s\n" "${UNSTABLE_REPOS[@]}"
			return 0
			;;
	esac
	return 1
}

get_stability_layer_between() {
	local layer_from=$1
	local layer_to=$2
	local reverse=${3:-0}

	local pass=cat
	local found=0

	if (( reverse )); then
		pass=tac
	fi

	for layer in $(printf '%s\n' "${STABILITY_LAYERS[@]}" | ${pass}); do
		if (( ! found )); then
			[[ $layer == "${layer_from}" ]] && found=1
			continue
		fi

		if [[ $layer == "${layer_to}" ]]; then
			return
		fi

		echo "${layer}"
	done
}

check_package_is_newer_than_repo() {
	local pkgfile=$1
	local repo=$2
	local pkgbase pkgarch pkgver
	local pkgver_repo vercmp_result

	if ! pkgbase=$(getpkgbase "${pkgfile}") || \
			! pkgarch=$(getpkgarch "${pkgfile}") || \
			!  pkgver=$(getpkgver "${pkgfile}"); then
		error "Package %s has invalid metadata" "${pkgfile}"
		return 1
	fi

	# it is okay if package does not exist in the current repo
	if ! pkgver_repo=$(pkgver_from_state_repo "${pkgbase}" "${repo}-${pkgarch}"); then
		return 0
	fi

	if ! vercmp_result=$(vercmp "${pkgver}" "${pkgver_repo}"); then
		error "Package %s failed to compare version %s against repo version %s" "${pkgfile}" "${pkgver}" "${pkgver_repo}"
		return 1
	fi

	if ! (( vercmp_result >= 1 )); then
		return 1
	fi
	return 0
}

check_staged_versions() {
	local -n staging_ref=$1
	local pkgname pkgver pkgarch
	local layer_lookup layer repo pkgfile pkgs
	local layer_above pkgver_above vercmp_result

	# build fast lookup table
	declare -A layer_lookup
	for repo in "${!staging_ref[@]}"; do
		# resolve stability layer for current repo
		if ! layer=$(get_stability_layer_from_repo "${repo}"); then
			error "Failed to get stability layer from repo %s" "${repo}"
			return 1
		fi

		# assign all staged repo packages to the fast lookup table
		read -ra pkgs <<< "${staging_ref[$repo]}"
		for pkgfile in "${pkgs[@]}"; do
			pkgname=$(getpkgname "${pkgfile}")
			pkgver=$(getpkgver "${pkgfile}")
			pkgarch=$(getpkgarch "${pkgfile}")

			# ensure no duplicate pkgname exists in the same stability layer
			# TODO: check for dupliace any+native variant
			if [[ "${layer_lookup["${layer}::${pkgname}::${pkgarch}"]+exists}" ]]; then
				error 'Package %s is staged in multiple repos of the same stability layer: %s and %s' \
					"${pkgfile##*/}" "${repo}" "${layer_lookup["${layer}::${pkgname}::repo"]}"
				return 1
			fi

			# assign lookup table data
			layer_lookup["${layer}::${pkgname}::${pkgarch}"]="${pkgfile}"
			layer_lookup["${layer}::${pkgname}::${pkgarch}::repo"]="${repo}"
			layer_lookup["${layer}::${pkgname}::${pkgarch}::pkgver"]="${pkgver}"
			layer_lookup["${layer}::${pkgname}::${pkgarch}::filename"]="${pkgfile##*/}"
		done
	done

	# check pkgver of all staged packages across all stability layers
	for repo in "${!staging_ref[@]}"; do
		# resolve stability layer for current repo
		if ! layer=$(get_stability_layer_from_repo "${repo}"); then
			error "Failed to get stability layer from repo %s" "${repo}"
			return 1
		fi

		# query all relevant layers between the current and outer layer
		mapfile -t layers < <(get_stability_layer_between "${layer}" unstable)

		# check each staging package
		read -ra pkgs <<< "${staging_ref[$repo]}"
		for pkgfile in "${pkgs[@]}"; do
			pkgname=$(getpkgname "${pkgfile}")
			pkgver=$(getpkgver "${pkgfile}")
			pkgarch=$(getpkgarch "${pkgfile}")

			# iterate through all layers above the current one
			for layer_above in "${layers[@]}"; do
				# skip layers that do not host the same package
				if [[ ! "${layer_lookup["${layer_above}::${pkgname}::${pkgarch}"]+exists}" ]]; then
					continue
				fi

				# compare current package against the current stability layer variant
				pkgver_above="${layer_lookup["${layer_above}::${pkgname}::${pkgarch}::pkgver"]}"
				if ! vercmp_result=$(vercmp "${pkgver_above}" "${pkgver}"); then
					error "Package %s failed to compare version %s against repo version %s" \
						"${pkgfile##*/}" "${pkgver}" "${pkgver_above}"
					return 1
				fi

				# fail if a layer above the current one does not provide a newer variant
				if ! (( vercmp_result > 0 )); then
					error "Package %s staged in repo %s is not newer than package %s staged in repo %s" \
						"${pkgfile##*/}" "${repo}" \
						"${layer_lookup["${layer_above}::${pkgname}::${pkgarch}::filename"]}" \
						"${layer_lookup["${layer_above}::${pkgname}::${pkgarch}::repo"]}"
					return 1
				fi
			done
		done
	done

	return 0
}

function array_append() {
	local -n array_ref=$1
	local key=$2
	local value="${*:3}"
	if [[ -v "array_ref[$key]" ]]; then
		array_ref["$key"]+=" "
	fi
	array_ref["$key"]+="${value}"
}


. "$(dirname "$(readlink -e "${BASH_SOURCE[0]}")")/db-functions-${VCS}"
